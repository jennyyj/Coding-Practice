# final preparation:


"""
1.
a) Write a function seq_save(filename, seq) that writes a sequence
(e.g. list) of strings seq to a file so that it is possible to recover
later the original sequence. The same strings and in the correct order.
The challenge is that strings may contain \n, so we can't use \n as
n element separator.

b) Write a function  seq_read(filename) that reads from the file and returns
a list with the sequence of strings previously saved with seq_save() to the
given file.

c) Write a function  seq_read_nth(filename, idx) that reads from the file
and returns just the string with index idx from the given file previously
saved with seq_save(). To maximize speed ,dDo NOT read any other string
from the file.

Do not use the csv module, json, pickle or similar.


2.
Write a recursive function file_find(direc, string) that finds
in directory direc and recursively in all its subdirectories
all files whose name includes the substring string.
Do NOT use function  os.walk(). 


3.
Write a recursive function print_flatten(lst) that prints to the terminal
all elements from a flattened version of list lst.

A "flat" list  is a list with no nested lists as elements.

E.g. if demolst = [[0,1],2,[3,[4,[5],6],7,[8,[9,10]]],11]
then print_flatten(demolst) displays 0 1 2 3 4 5 6 7 8 9 10 11


4. 
Write a recursive function flatten(lst) that returns a flat list with all
elements from parameter lst.

E.g. if demolst = [[0,1],2,[3,[4,[5],6],7,[8,[9,10]]],11]
then flatten(demolst) returns [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]


5.
Write a recursive function flatten_pure(lst) that does the same thing as
function flatten(lst) but without using a for loop or any side effects.



6.
Consider the functions defined below:
def compose(f, g):
    def compose_fun(x):    # inner function is visible only in compose()
        return f(g(x))     # However, we can call it if we have its obj. ref.

    return compose_fun


def upper_bound(maxval):
    return lambda x: min(x, maxval)

def square(x):
    return x * x

# a demo list:
numb_lst = [4, -2, 0, 5, 3, -6, 3, 1, 5]

Write an expression using the standard map() function and the functions
defined above that computes a list where each element is either the
square of the corresponding element in numb_lst or 20, if the square
exceeds 20.
For the example above, that list is [16, 4, 0, 20, 9, 20, 9, 1, 20].


7.
Write a generator cycle_seq(seq) that generates indefinitely a
repeated sequence with all the elements in sequence seq.

E.g.: if seq_345 generates elements 3,4,5 (e.g. seq_345==(3,4,5)), then
for  i in cycle seq_345:
    print(i, end=" ")

would print 3 4 5 3 4 5 3 4 5 3 4 5 3 4 5 3 4 5 ...


8.
Write a generator function enumerate_seq(seq) that returns
a sequence of tuples (i, x) for each element x from seq, with i
being the index of x in seq.

E.g. if seq==["abc", 10, "def"]
enumerate_seq(seq) returns the sequence (0, "abc"), (1, 10), (2, "def")


9.
a) Write a  generator fgen_diff(sqe) that yields the difference between succesive
elements in a sequence seq.
E.g. if seq==(4,1,3,-2,0) then gen_diff(seq) generates sequence (-3,2,-5,2).

b) 
Use gen_diff(), the map, filter, and functools.reduce
functions with lambda expressions
to write an expression that computes the maximum difference between
the sequence of squares of  odd numbers from the original sequence.

E.g. if seq is the sequence of numbers 2,-1,5,4,3,6,4,-3,0,5,7
then the odd number sequence is -1,5,3,-3,5,7,
the corresponding sequence of squares is 1, 25, 9, 9, 25, 49,
the differences are: 24, -16, 0, 16, 24,
the maximum from these is 24.


10.
Do the same as 9 in a Pythonic way, using generator expressions
and for loops.


11.
To decimate a sequence of numbers means to allow to pass only each 10th
element from the sequence.
Decimation these days could be used for sampling from a long stream of
sensor data where you are interested only every n values from the stream.

Write a generator function decimate(n, seq) that yields every n value
from the stream.

E.g. decimate(3, range(2)) should generate the stream 0, 3, 6, 9, 12, 15, 18.
What can we say about the numbers generated by expression
decimate(4, decimate(3, range(100))) ?


12.
Write a generator scan(fun, initial) that yields the sequence of
accumulated results of a sequence by applying the function
fun (of two arguments) to the runnig accumulated result and the
current element.

Example: if seq=(1,2,3,4,5), scan(lambda x,y:x+y, 0, seq) yields
sequence (0, 1, 3, 6, 10, 15), i.e.
the sequence (0 (initial value), 0+1, 0+1+2, 0+1+2+3, 0+1+2+3+4, 0+1+2+3+4+5)

This works for lists too !
a) Write an expression using scan() that computes the running concatenation
of lists in tuple ([0,1], [2], [3,4,5], [6], [7,8,9]).
The result should look like:
([], [0, 1], [0, 1, 2], [0, 1, 2, 3, 4, 5], [0, 1, 2, 3, 4, 5, 6],
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9])




"""

import os
import sys
import functools


# $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
    
def testif(b, testname, msgOK="", msgFailed=""):
    """Function used for testing. 
    param b: boolean, normally a tested condition: true if test passed, false otherwise
    param testname: the test name
    param msgOK: string to be printed if param b==True  ( test condition true)
    param msgFailed: string to be printed if param b==False
    returns b
    """
    if b:
        print("Success: "+ testname + "; " + msgOK)
    else:
        print("Failed: "+ testname + "; " + msgFailed)
    return b
# ----------------------------------------------------------------

# problem 1. 
# ---------------------------------------------------
def seq_save(filename, seq):
    """Save a sequence of strings to a text file in a way that allows recovery
    of the original sequence.
    The challenge is that strings may contain \n, so we can't use \n as
    an element separator.
    """
    with open(filename, "w") as f:
        for s in seq:
            f.write(str(len(s)) + "\n")
            f.write(s)

def seq_read(filename):
    """Read a sequence of strings from a text file back to a list of strings.
    """ 
    with open(filename, "r") as f:
        lst = []
        sz = 0
        while sz >= 0:
            sz = -1
            line = f.readline()
            if len(line) > 0:
                sz = int(line.strip())
                s = f.read(sz)
                lst.append(s)
        return lst

def seq_read_nth(filename, idx):
    """Read the string with index idx from the file.
    Returns "" if not 0<=idx<sequence length.
    """
    ret = ""
    if idx < 0:
        return ""
    with open(filename, "r") as f:
        lst = []        
        while True:
            line = f.readline()
            if len(line) > 0:
                sz = int(line.strip())
                if idx == 0:
                    return f.read(sz)
                else:
                    f.seek(f.tell() + sz)
                    idx -= 1
            else:
                return ""

def test_seq_io():
    fn = "seq-test.txt"
    lst1 = ["abc","0","123\n\n567", "89", "", "", "z"]
    seq_save(fn, lst1)
    lst2 = seq_read(fn)
    testif(lst1 == lst2, "seq write and read")

    for n in range(len(lst1)):
        testif(lst1[n] == seq_read_nth(fn, n), "seq_read_nth: n={}".format(n))
        

    n = -1
    testif("" == seq_read_nth(fn, n), "seq_read_nth: n={}".format(n))
    n = len(lst1)
    testif("" == seq_read_nth(fn, n), "seq_read_nth: n={}".format(n))
    
test_seq_io()

# ===========================================================

# problem 2.

def file_find(direc, string):
    """Find recursively all files under directory direc with names that
    include substring string."""
    def filename_search(filename, string):
        """Search for string in file name."""
        if filename.find(string) >= 0:
            print("Found", filename)

    files = []
    subdirs = []
    for f in os.listdir(direc):
        name = os.path.join(direc, f)
        if os.path.isfile(name):
            files.append(name)
        if os.path.isdir(name):
            subdirs.append(name)

    for f in files:
        filename_search(f, string)

    for d in subdirs:
        file_find(d, string)    # <--- recursive call
        

# THis coould be done easier with the os.walk() function:                    
#    for dir_name, dirs, files in os.walk(direc):
#        print(dir_name, dirs, files)

#file_find(".", '.py')

# ===========================================================

# Problem 3.

def print_flatten(lst):
    for x in lst:
        if type(x) != list and type(x) != tuple:
            print(x, end=" ")
        else:
            print_flatten(x)

# ===========================================================

# Problem 4:

def flatten(lst):
    locall = []
    for x in lst:
        if type(x) != list and type(x) != tuple:
            locall.append(x)
        else:
            locall.extend(flatten(x))
    return locall
                              
# ===========================================================

# Problem 5:

# version that passes the accumulated list in the second param ll
def flatten_pure(lst):
    """Returns  flat list with all elements (non-list/non-tuple) from lst."""
    def flatten_pure_aux(lst, ll):
        if lst == []:
            return ll
        if type(lst[0]) != list and type(lst[0]) != tuple:
            # not a collection:
            return flatten_pure_aux(lst[1:], ll + [lst[0]])
        return flatten_pure_aux(lst[1:], ll + flatten_pure(lst[0]))

    return flatten_pure_aux(lst, [])


# version that does not rely on a second parameter:
def flatten_pure2(lst):
    """Returns  flat list with all elements (non-list/non-tuple) from lst."""
    if lst == []:
        return []
    if type(lst[0]) != list and type(lst[0]) != tuple:
        # not a list/tuple:
        return [lst[0]] + flatten_pure2(lst[1:])
    # lst[0] is a nested list or tuple:
    return flatten_pure2(lst[0]) + flatten_pure2(lst[1:])

demolst = [[0,1],2,[3,[4,[5],6],7,[8,[9,10]]],11]
print_flatten(demolst)
print()
print(flatten(demolst))
print(flatten_pure(demolst))
print(flatten_pure2(demolst))


# =========================================================

# Problem 6.

def compose(f, g):
    """Returns a new function that is f(g(x)), i.e. (f o g)(x)
    f and g must be functions."""
    def compose_fun(x):    # inner function is visible only in compose()
        return f(g(x))     # However, we can call it if we have its obj. ref.

    return compose_fun


def upper_bound(maxval):
    return lambda x: min(x, maxval)

def square(x):
    return x * x

numb_lst = [4, -2, 0, 5, 3, -6, 3, 1, 5]

# computes list with squares of numbers from list or 20 if the square > 20:
limited_squares = map(compose(upper_bound(20), square), numb_lst)
print([x for x in limited_squares])


# =========================================================

# Problem 7.

def cycle_seq(seq):
    """Cycles through all elements from iterable seq."""
    lst = [x for x in seq]
    while True:
        for i in lst:
            yield i

# uncomment for infinite cycling:
#for i in cycle_seq((3,4,5)):
#    print(i, end=" ")
    


# =========================================================

# Problem 8.
 
def enumerate_seq(seq):
    i = 0
    for x in seq:
        yield (i, x)
        i = i + 1

for tup in enumerate_seq(["abc", 10, "def"]):
    print(tup)
    


# =========================================================

# Problem 9.

def gen_diff(seq):
    it = iter(seq)
    x = next(it)
    for y in it:
        yield y - x
        x = y

seq = [2,-1,5,4,3,6,4,-3,0,5,7]
odds = filter(lambda x: x%2!=0, seq)
squares_odds = map(lambda y: y*y, odds)
differences = gen_diff(squares_odds)
m = functools.reduce(max, differences)
print("Max difference between successive squares of odd numbers:",m)

#in one expression:
m = functools.reduce(max, gen_diff(map(lambda y: y*y,
                                       filter(lambda x: x%2!=0, seq))))
print("Max difference between successive squares of odd numbers from seq:",m)

# =========================================================

# Problem 10.

# no change:
def gen_diff(seq):
    """Generate sequence with the differences between adjacent elements in seq.
    If seq has less then two elements then it generates the empty sequence.
    Check out with list(gen_diff([1]))"""
    it = iter(seq)
    x = next(it)
    for y in it:
        yield y - x
        x = y


seq = [2,-1,5,4,3,6,4,-3,0,5,7]
odds = (i for i in seq if i%2!=0)
squares_odds = (i*i for i in odds)
differences = gen_diff(squares_odds)
m = -1
for x in differences:
    if x < m:
        m = x

# or just:
#  m = max(differences)

# in one expression:
m = max(gen_diff(i*i for i in seq if i % 2!=0))  # beautiful!
print("Max difference between successive squares of odd numbers from seq:",m)



# =========================================================

# Problem 11.

def decimate(n, seq):
    """Yield each nth elements from sequence.
    """
    i = 0
    for x in seq:
        if i % n == 0:
            yield x
        i += 1
            
print("Decimation by 3 and by 4: ", tuple(decimate(4, decimate(3, range(100)))))



# =========================================================

# Problem 12.

def scan(fun, initial, seq):
    """Generates the sequence of accumulated results of applying the
    func function on the current running result the next element from seq.
    """
    s = initial
    yield s
    for x in seq:
        s = fun(s, x)
        yield s
        
# a)        
# print the sequence of partial sums in range(0,10):
print(tuple(scan(lambda x,y: x+y, 0, range(10))))

# b) 
# compute the partial concatenations of a sequence of lists:
tuple(scan(lambda a,b: a+b, [], ([0,1], [2], [3,4,5], [6], [7,8,9])))

